name: Label Approved PR

# This workflow uses workflow_run to trigger AFTER the review workflow
# It runs in the base repo context with FULL PERMISSIONS even for fork PRs
permissions:
  pull-requests: write
  issues: write
  actions: read

on:
  workflow_run:
    workflows: ["PR Review Trigger"]
    types: [completed]

jobs:
  label-pr:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Get PR number and add labels
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            console.log('=== Workflow Run Event ===');
            
            const workflowRun = context.payload.workflow_run;
            
            if (!workflowRun) {
              console.log('❌ No workflow_run found in context');
              return;
            }
            
            console.log('Triggered by:', workflowRun.name);
            console.log('Conclusion:', workflowRun.conclusion);
            
            // Get PR number - works for both fork and same-repo PRs
            let prNumber;
            
            // First try the pull_requests array (works for same-repo PRs)
            const pullRequests = workflowRun.pull_requests;
            
            if (pullRequests && pullRequests.length > 0) {
              prNumber = pullRequests[0].number;
              console.log(`✓ Found PR #${prNumber} from pull_requests array`);
            } else {
              // Fallback: Search for PR by commit SHA (works for fork PRs)
              console.log('⚠️ pull_requests array empty, searching by commit SHA...');
              
              try {
                const { data } = await github.rest.search.issuesAndPullRequests({
                  q: `repo:${context.repo.owner}/${context.repo.repo} is:pr sha:${workflowRun.head_sha}`,
                  per_page: 1,
                });
                
                if (data.items.length === 0) {
                  console.log('❌ No PR found for this workflow run');
                  return;
                }
                
                prNumber = data.items[0].number;
                console.log(`✓ Found PR #${prNumber} via commit SHA search`);
              } catch (error) {
                console.log('❌ Failed to find PR:', error.message);
                return;
              }
            }
            
            console.log(`\n=== Processing PR #${prNumber} ===`);
            
            // Fetch PR details to get the author
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            const prAuthor = pr.user.login;
            console.log(`PR Author: ${prAuthor}`);
            
            // Fetch all reviews for this PR
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            console.log(`Total reviews: ${reviews.length}`);
            
            // Get latest review from each user
            const latestByUser = {};
            for (const r of reviews) {
              if (!r.user?.login) continue;
              const login = r.user.login;
              const when = r.submitted_at || r.created_at;
              
              console.log(`  Review by ${login}: ${r.state} at ${when}`);
              
              if (!latestByUser[login] || new Date(when) > new Date(latestByUser[login].submitted_at || latestByUser[login].created_at)) {
                latestByUser[login] = r;
              }
            }

            // Separate approvals into owner and external
            let ownerApproved = false;
            let externalApproved = false;
            
            for (const [reviewer, review] of Object.entries(latestByUser)) {
              if (review.state === 'APPROVED') {
                if (reviewer === prAuthor) {
                  ownerApproved = true;
                  console.log(`✓ Owner (${reviewer}) approved`);
                } else {
                  externalApproved = true;
                  console.log(`✓ External reviewer (${reviewer}) approved`);
                }
              }
            }

            console.log(`\nOwner approved: ${ownerApproved}`);
            console.log(`External approved: ${externalApproved}`);

            // Get current labels
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });
            
            const currentLabelNames = currentLabels.map(l => l.name);
            console.log(`Current labels: ${currentLabelNames.join(', ') || 'none'}`);

            // Determine labels to add/remove
            const labelsToAdd = [];
            const labelsToRemove = [];
            
            // Handle external:approved label
            if (externalApproved && !currentLabelNames.includes('external:approved')) {
              labelsToAdd.push('external:approved');
            } else if (!externalApproved && currentLabelNames.includes('external:approved')) {
              labelsToRemove.push('external:approved');
            }
            
            // Handle owner:approved label
            if (ownerApproved && !currentLabelNames.includes('owner:approved')) {
              labelsToAdd.push('owner:approved');
            } else if (!ownerApproved && currentLabelNames.includes('owner:approved')) {
              labelsToRemove.push('owner:approved');
            }

            console.log(`Labels to add: ${labelsToAdd.join(', ') || 'none'}`);
            console.log(`Labels to remove: ${labelsToRemove.join(', ') || 'none'}`);

            // Add labels
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: labelsToAdd
              });
              console.log(`✅ Added labels: ${labelsToAdd.join(', ')}`);
            }
            
            // Remove labels
            for (const label of labelsToRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: label
                });
                console.log(`✅ Removed label: ${label}`);
              } catch (error) {
                console.log(`⚠️ Could not remove label ${label}: ${error.message}`);
              }
            }
            
            if (labelsToAdd.length === 0 && labelsToRemove.length === 0) {
              console.log('ℹ️ No label changes needed');
            }
